/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./public/js/game.js":
/*!***************************!*\
  !*** ./public/js/game.js ***!
  \***************************/
/***/ (() => {

eval("const config = {\r\n  type: Phaser.AUTO,\r\n  width: 500,\r\n  height: 700,\r\n  parent: 'game-container',\r\n  scene: { preload, create, update }\r\n};\r\n\r\nconst game = new Phaser.Game(config);\r\n\r\nlet gameOver = false;\r\nlet currentPlayer = 1;\r\nlet playerID = 1;\r\nlet rookSelected = false;\r\nlet timerText;\r\nlet turnTime = 30;\r\nlet timerEvent;\r\nlet timerCircle;\r\nlet rookMoved = false;\r\nlet playerActive = [true, true]; // Both players are active now\r\nlet highlightGraphics = [];\r\nlet hasPlayerWon = false;\r\n\r\nfunction preload() {\r\n  this.load.image('chessboard', 'images/chessboard.png');\r\n  this.load.image('rook', 'images/rook.png');\r\n  this.load.image('target', 'images/target.png');\r\n  this.load.image('avatar1', 'images/player-one.png');\r\n  this.load.image('avatar2', 'images/player-two.png');\r\n}\r\n\r\nfunction create() {\r\n  this.add.image(250, 350, 'chessboard');\r\n  const rook = this.add.sprite(375, 175, 'rook');\r\n  const target = this.add.sprite(40, 490, 'target').setOrigin(0);\r\n  const avatar1 = this.add.sprite(250, 50, 'avatar1').setScale(0.1);\r\n  const avatar2 = this.add.sprite(250, 650, 'avatar2').setScale(0.1);\r\n\r\n  timerCircle = this.add.graphics();\r\n  timerCircle.fillStyle(0x00FF00, 1);\r\n  timerCircle.fillCircle(avatar1.x + avatar1.width * 0.6, avatar1.y + avatar1.height * 0.5, 30);\r\n  timerCircle.visible = false;\r\n\r\n  rook.setInteractive();\r\n  this.input.on('pointerdown', () => {\r\n    if (!gameOver && playerActive[currentPlayer - 1]) {\r\n      rookSelected = true;\r\n      rook.setTint(0xff0000);\r\n      console.log('Rook selected');\r\n    }\r\n  });\r\n  \r\n  this.input.on('pointerup', () => {\r\n    if (rookSelected && playerActive[currentPlayer - 1]) {\r\n      rookSelected = false;\r\n      rook.clearTint();\r\n      rookMoved = true;\r\n      endTurn();\r\n      console.log('Rook deselected');\r\n    }\r\n  });\r\n\r\n  timerText = this.add.text(10, 10, 'Time left: ' + turnTime, { fontSize: '16px', fill: '#ffffff' });\r\n  startTurnTime(this);\r\n}\r\n\r\nfunction update() {\r\n  timerText.setText('Time left: ' + turnTime);\r\n\r\n  if (!gameOver) {\r\n    const rook = this.children.list.find(child => child.texture.key === 'rook');\r\n    const target = this.children.list.find(child => child.texture.key === 'target');\r\n\r\n    if (rookSelected && this.input.activePointer.isDown) {\r\n      const minX = 75, maxX = 650, minY = 100, maxY = 525;\r\n      const newX = Phaser.Math.Clamp(this.input.activePointer.x, minX, maxX);\r\n      const newY = Phaser.Math.Clamp(this.input.activePointer.y, minY, maxY);\r\n\r\n      if (newX <= rook.x && newY >= rook.y) {\r\n        rook.x = newX;\r\n        rook.y = newY;\r\n        console.log('Rook position updated:', newX, newY);\r\n\r\n        // Check if the rook reaches the target position\r\n        if (rook.x === target.x && rook.y === target.y) {\r\n          gameOver = true;\r\n          showPopup(\"Player \" + currentPlayer + \" wins by reaching the target!\");\r\n          restartGame();\r\n        }\r\n      }\r\n    }\r\n\r\n    // Highlight valid moves for the rook\r\n    highlightValidMoves(rook, target);\r\n\r\n    timerCircle.visible = playerActive[currentPlayer - 1];\r\n    if (playerActive[currentPlayer - 1]) {\r\n      const avatar = this.children.list.find(child => child.texture.key === `avatar${currentPlayer}`);\r\n      timerCircle.x = avatar.x + avatar.width * 0.6;\r\n      timerCircle.y = avatar.y + avatar.height * 0.5;\r\n    }\r\n  } else {\r\n    timerCircle.visible = false;\r\n  }\r\n}\r\n\r\nfunction highlightValidMoves(rook, target) {\r\n  // Highlight moves to the left and down\r\n  const minX = 75, minY = 100;\r\n  const boxWidth = 78, boxHeight = 79;\r\n\r\n  const targetX = target.x;\r\n  const targetY = target.y;\r\n\r\n  // Calculate number of moves to the left\r\n  const leftMoves = Math.floor((rook.x - targetX) / boxWidth);\r\n  // Calculate number of moves down\r\n  const downMoves = Math.floor((targetY - rook.y) / boxHeight);\r\n\r\n  // Clear any previous highlights\r\n  clearHighlights.call(this); // Call clearHighlights with the correct context\r\n\r\n  // Highlight the left moves\r\n  for (let i = 1; i <= leftMoves; i++) {\r\n    const x = rook.x - i * boxWidth;\r\n    const y = rook.y;\r\n    highlightMove.call(this, x, y, boxWidth, boxHeight); // Call highlightMove with the correct context\r\n  }\r\n\r\n  // Highlight the down moves\r\n  for (let i = 1; i <= downMoves; i++) {\r\n    const x = rook.x;\r\n    const y = rook.y + i * boxHeight;\r\n    highlightMove.call(this, x, y, boxWidth, boxHeight); // Call highlightMove with the correct context\r\n  }\r\n\r\n  // Check if rook's position matches target's position\r\n  if (rook.x <= targetX + target.width && rook.y >= targetY && !hasPlayerWon) {\r\n    // Display popup message\r\n    showPopup.call(this, \"Player \" + currentPlayer + \" wins!\");\r\n    hasPlayerWon = true;\r\n  }\r\n}\r\n\r\n\r\nfunction highlightMove(x, y, width, height) {\r\n  if (!this.add) {\r\n    console.error(\"this.add is not defined\");\r\n    return;\r\n  }\r\n\r\n  const decreaseFactor = 0.5; // Adjust this factor as needed\r\n  const newWidth = width * decreaseFactor;\r\n\r\n  const graphics = this.add.graphics();\r\n  graphics.fillStyle(0xff0000, 0.5);\r\n  graphics.fillRect(x + (width - newWidth) / 2, y + height / 4, newWidth, height / 2);\r\n  highlightGraphics.push(graphics);\r\n}\r\n\r\n\r\n\r\nfunction clearHighlights() {\r\n  highlightGraphics.forEach(graphics => {\r\n    graphics.destroy();\r\n  });\r\n  highlightGraphics = [];\r\n}\r\n\r\nfunction startTurnTime(scene) {\r\n  timerEvent = scene.time.addEvent({ delay: 1000, callback: updateTurnTime, callbackScope: scene, loop: true });\r\n}\r\n\r\nfunction updateTurnTime() {\r\n  if (currentPlayer === playerID && !gameOver) {\r\n    turnTime--;\r\n    if (turnTime === 0) {\r\n      if (!rookMoved) {\r\n        endTurn();\r\n        showPopup(\"Player \" + (currentPlayer === 1 ? 2 : 1) + \" wins! Player \" + currentPlayer + \" ran out of time.\");\r\n      } else {\r\n        turnTime = 30;\r\n        rookMoved = false;\r\n        endTurn();\r\n        startTurnTime(this);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n\r\nfunction endTurn() {\r\n  currentPlayer === 1 ? 2 : 1;\r\n  turnTime = 30;\r\n  console.log(\"Player \" + currentPlayer + \"'s move now.\");\r\n}\r\n\r\nfunction showPopup(message) {\r\n  alert(message);\r\n}\r\n\r\nfunction restartGame() {\r\n  gameOver = false;\r\n  currentPlayer = 1;\r\n  turnTime = 30;\r\n  rookMoved = false;\r\n  clearHighlights();\r\n  console.log(\"Game restarted.\");\r\n}\r\n\n\n//# sourceURL=webpack://cuemath/./public/js/game.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./public/js/game.js"]();
/******/ 	
/******/ })()
;